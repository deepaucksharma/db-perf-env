---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\.env---
# MySQL Configuration
MYSQL_HOST=mysql
MYSQL_USER=root
MYSQL_PASSWORD=pass
MYSQL_DATABASE=employees

# New Relic
NEW_RELIC_LICENSE_KEY=a9bc072c174b9f10e2f1581d45faa91cFFFFNRAL
NEW_RELIC_APP_NAME_HR=HR-Portal
NEW_RELIC_APP_NAME_PAYROLL=Payroll-System
NEW_RELIC_APP_NAME_REPORTING=Reporting-Dashboard
NEW_RELIC_APP_NAME_PERFORMANCE=Performance-Review
NEW_RELIC_APP_NAME_ADMIN=Admin-Console

# Application Ports
HR_PORTAL_PORT=3000
PAYROLL_SYSTEM_PORT=3001

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\docker-compose.yml---
version: '3.8'

services:    
  hr-portal:
    build:
      context: ./hr-portal
    environment:
      - MYSQL_HOST=host.docker.internal
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - NEW_RELIC_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY}
      - NODE_ENV=production
    ports:
      - "${HR_PORTAL_PORT}:3000"
    mem_limit: 2G
    
  payroll-system:
    build:
      context: ./payroll-system
    environment:
      - MYSQL_HOST=host.docker.internal
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - NEW_RELIC_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY}
      - NODE_ENV=production
    ports:
      - "3001:3001"
    mem_limit: 2G

  reporting-dashboard:
    build:
      context: ./reporting-dashboard
    environment:
      - MYSQL_HOST=host.docker.internal
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - NEW_RELIC_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY}
      - NODE_ENV=production
    ports:
      - "3002:3002"
    mem_limit: 2G

  performance-review:
    build:
      context: ./performance-review
    environment:
      - MYSQL_HOST=host.docker.internal
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - NEW_RELIC_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY}
      - NODE_ENV=production
    ports:
      - "3003:3003"
    mem_limit: 2G

  admin-console:
    build:
      context: ./admin-console
    environment:
      - MYSQL_HOST=host.docker.internal
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - NEW_RELIC_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY}
      - NODE_ENV=production
    ports:
      - "3004:3004"
    mem_limit: 2G

  k6:
    image: grafana/k6
    volumes:
      - ./k6:/scripts
    environment:
      - HR_PORTAL_URL=http://hr-portal:3000
      - PAYROLL_SYSTEM_URL=http://payroll-system:3001
      - REPORTING_DASHBOARD_URL=http://reporting-dashboard:3002
      - PERFORMANCE_REVIEW_URL=http://performance-review:3003
      - ADMIN_CONSOLE_URL=http://admin-console:3004
    depends_on:
      - hr-portal
      - payroll-system
      - reporting-dashboard
      - performance-review
      - admin-console
    command: run /scripts/load-test.js

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\admin-console\app.js---
// admin-console/app.js
const newrelic = require('newrelic');
console.log('New Relic agent status:', newrelic.agent.config.agent_enabled);
const express = require('express');
const mysql = require('mysql2/promise');

// Basic logging middleware
const requestLogger = (serviceName) => (req, res, next) => {
  const startTime = Date.now();
  
  // Override res.json to capture the response
  const originalJson = res.json;
  res.json = function(data) {
    const duration = Date.now() - startTime;
    console.log(`${serviceName} | ${req.method} ${req.originalUrl} | Status: ${res.statusCode} | ${duration}ms${data.error ? ` | Error: ${data.error}` : ''}`);
    return originalJson.apply(this, arguments);
  };

  next();
};

async function startAdminConsole() {
  const pool = await mysql.createPool({
    host: process.env.MYSQL_HOST || 'localhost',
    user: process.env.MYSQL_USER || 'root',
    password: process.env.MYSQL_PASSWORD || '',
    database: process.env.MYSQL_DATABASE || 'employees',
    connectionLimit: 10,
    queueLimit: 0,
    waitForConnections: true
  });

  const app = express();
  app.use(express.json());
  app.use(requestLogger('Admin-Console'));

  app.get('/health', (req, res) => {
    res.json({ status: 'ok' });
  });

  // 1. Complex employee search
  app.get('/admin/employees/search', async (req, res) => {
    newrelic.setTransactionName('admin-console-employee-search');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT DISTINCT 
          e.emp_no, e.first_name, e.last_name, e.hire_date,
          t.title, s.salary, d.dept_name,
          (SELECT COUNT(*) 
           FROM titles t2 
           WHERE t2.emp_no = e.emp_no) as role_changes,
          (SELECT MAX(salary) 
           FROM salaries s2 
           WHERE s2.emp_no = e.emp_no) as highest_salary
        FROM employees e
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        WHERE (e.first_name LIKE '%ar%' OR e.last_name LIKE '%son%')
        AND t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        AND s.salary > 60000
        AND YEAR(e.hire_date) > 1990
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 2. Bulk title update with transaction
  app.put('/admin/employees/bulk_title_update', async (req, res) => {
    newrelic.setTransactionName('admin-console-bulk-title-update');
    const connection = await pool.getConnection();
    try {
      await connection.beginTransaction();
      
      // End current titles
      await connection.query(`
        UPDATE titles t
        JOIN dept_emp de ON t.emp_no = de.emp_no
        SET t.to_date = CURDATE()
        WHERE de.dept_no = 'd005'
        AND t.title = 'Engineer'
        AND t.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
      `);
      
      // Insert new titles
      await connection.query(`
        INSERT INTO titles (emp_no, title, from_date, to_date)
        SELECT t.emp_no, 'Senior Engineer', CURDATE(), '9999-01-01'
        FROM titles t
        JOIN dept_emp de ON t.emp_no = de.emp_no
        WHERE de.dept_no = 'd005'
        AND t.to_date = CURDATE()
        AND de.to_date = '9999-01-01'
      `);
      
      await connection.commit();
      res.json({ status: 'ok' });
    } catch (err) {
      newrelic.noticeError(err);
      await connection.rollback();
      res.status(500).json({ error: err.message });
    } finally {
      connection.release();
    }
  });

  // 3. Department management audit
  app.get('/admin/departments/details', async (req, res) => {
    newrelic.setTransactionName('admin-console-department-details');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          d.dept_no,
          d.dept_name,
          COUNT(DISTINCT de.emp_no) as current_employees,
          COUNT(DISTINCT dm.emp_no) as total_managers,
          MIN(dm.from_date) as first_manager_date,
          COUNT(DISTINCT t.title) as unique_titles,
          AVG(s.salary) as avg_salary,
          (SELECT COUNT(*) 
           FROM dept_emp de2 
           WHERE de2.dept_no = d.dept_no 
           AND de2.to_date < CURDATE()) as past_employees
        FROM departments d
        LEFT JOIN dept_emp de ON d.dept_no = de.dept_no AND de.to_date = '9999-01-01'
        LEFT JOIN dept_manager dm ON d.dept_no = dm.dept_no
        LEFT JOIN titles t ON de.emp_no = t.emp_no AND t.to_date = '9999-01-01'
        LEFT JOIN salaries s ON de.emp_no = s.emp_no AND s.to_date = '9999-01-01'
        GROUP BY d.dept_no, d.dept_name
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 4. Employee details with history
  app.get('/admin/employees/details', async (req, res) => {
    newrelic.setTransactionName('admin-console-employee-details');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          e.emp_no, e.first_name, e.last_name, e.hire_date,
          t.title as current_title,
          s.salary as current_salary,
          d.dept_name as current_department,
          (SELECT GROUP_CONCAT(title ORDER BY from_date SEPARATOR ', ')
           FROM titles
           WHERE emp_no = e.emp_no) as title_history,
          (SELECT GROUP_CONCAT(CONCAT(dept_name, ': ', de2.from_date, ' to ', 
            CASE WHEN de2.to_date = '9999-01-01' THEN 'present' 
                 ELSE de2.to_date END)
            ORDER BY de2.from_date SEPARATOR '; ')
           FROM dept_emp de2 
           JOIN departments d2 ON de2.dept_no = d2.dept_no
           WHERE de2.emp_no = e.emp_no) as department_history
        FROM employees e
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        WHERE e.emp_no = 10001
        AND t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 5. Salary audit report
  app.get('/admin/reports/salary_audit', async (req, res) => {
    newrelic.setTransactionName('admin-console-salary-audit');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          e.emp_no, e.first_name, e.last_name,
          s1.salary as current_salary,
          s1.from_date as current_salary_date,
          (SELECT s2.salary 
           FROM salaries s2 
           WHERE s2.emp_no = e.emp_no 
           AND s2.to_date < '9999-01-01' 
           ORDER BY s2.to_date DESC LIMIT 1) as previous_salary,
          d.dept_name,
          t.title,
          (SELECT AVG(s3.salary) 
           FROM salaries s3 
           JOIN dept_emp de2 ON s3.emp_no = de2.emp_no 
           WHERE de2.dept_no = de.dept_no 
           AND s3.to_date = '9999-01-01') as dept_avg_salary
        FROM employees e
        JOIN salaries s1 ON e.emp_no = s1.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        JOIN titles t ON e.emp_no = t.emp_no
        WHERE s1.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 6. Employee transfer audit
  app.get('/admin/reports/transfer_audit', async (req, res) => {
    newrelic.setTransactionName('admin-console-transfer-audit');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          d1.dept_name as from_department,
          d2.dept_name as to_department,
          COUNT(*) as transfer_count,
          AVG(DATEDIFF(de2.from_date, de1.from_date)) as avg_days_between_transfers
        FROM dept_emp de1
        JOIN dept_emp de2 ON de1.emp_no = de2.emp_no
        JOIN departments d1 ON de1.dept_no = d1.dept_no
        JOIN departments d2 ON de2.dept_no = d2.dept_no
        WHERE de2.from_date > de1.from_date
        AND NOT EXISTS (
          SELECT 1 FROM dept_emp de3
          WHERE de3.emp_no = de1.emp_no
          AND de3.from_date > de1.from_date
          AND de3.from_date < de2.from_date
        )
        GROUP BY d1.dept_name, d2.dept_name
        HAVING transfer_count > 1
        ORDER BY transfer_count DESC
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 7. Data export with connection leaks
  app.get('/admin/employees/data_export', async (req, res) => {
    newrelic.setTransactionName('admin-console-data-export');
    const connections = [];
    try {
      for (let i = 0; i < 10; i++) {
        const connection = await pool.getConnection();
        connections.push(connection);
        await connection.query(`
          SELECT e.*, s.salary, t.title, d.dept_name
          FROM employees e
          JOIN salaries s ON e.emp_no = s.emp_no
          JOIN titles t ON e.emp_no = t.emp_no
          JOIN dept_emp de ON e.emp_no = de.emp_no
          JOIN departments d ON de.dept_no = d.dept_no
          WHERE s.to_date = '9999-01-01'
          AND t.to_date = '9999-01-01'
          AND de.to_date = '9999-01-01'
          LIMIT 1000 OFFSET ${i * 1000}
        `);
      }
      res.json({ status: 'ok' });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      // Delayed release to simulate connection leaks
      setTimeout(() => {
        connections.forEach(conn => conn.release());
      }, 5000);
    }
  });

  // 8. Inefficient prepared statements
  app.put('/admin/employees/update_multiple', async (req, res) => {
    newrelic.setTransactionName('admin-console-update-multiple');
    let connection;
    try {
      connection = await pool.getConnection();
      const [employees] = await connection.query(`
        SELECT emp_no FROM employees LIMIT 100
      `);

      // Prepare statement for each update instead of reusing
      for (const emp of employees) {
        await connection.query(`
          UPDATE employees 
          SET last_name = CONCAT(last_name, ?)
          WHERE emp_no = ?
        `, ['-updated', emp.emp_no]);
      }
      res.json({ status: 'ok' });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  const port = process.env.PORT || 3004;
  app.listen(port, () => console.log(`Admin Console running on port ${port}`));
}

startAdminConsole().catch(console.error);

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\admin-console\Dockerfile---
FROM node:18-alpine

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

ARG PORT=3004
ENV PORT=${PORT}

COPY . .

EXPOSE ${PORT}

HEALTHCHECK --interval=5s --timeout=3s --start-period=5s --retries=3 CMD curl -f http://localhost:${PORT}/health || exit 1

CMD ["node", "--max-old-space-size=2048", "app.js"]

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\admin-console\newrelic.js---
'use strict';

exports.config = {
  app_name: ['Admin-Console'],
  license_key: process.env.NEW_RELIC_LICENSE_KEY,
  distributed_tracing: {
    enabled: true
  },
  transaction_tracer: {
    record_sql: 'raw',
    explain_threshold: 500
  },
  slow_sql: {
    enabled: true,
    max_samples: 10
  },
  logging: {
    level: 'info'
  }
};

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\admin-console\package.json---
{
  "name": "admin-console",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.5",
    "newrelic": "12.8.2"
  }
}

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\hr-portal\app.js---
const newrelic = require("newrelic");
console.log("New Relic agent status:", newrelic.agent.config.agent_enabled);
const express = require("express");
const mysql = require("mysql2/promise");

// Basic logging middleware
const requestLogger = (serviceName) => (req, res, next) => {
  const startTime = Date.now();

  // Override res.json to capture the response
  const originalJson = res.json;
  res.json = function (data) {
    const duration = Date.now() - startTime;
    console.log(
      `${serviceName} | ${req.method} ${req.originalUrl} | Status: ${
        res.statusCode
      } | ${duration}ms${data.error ? ` | Error: ${data.error}` : ""}`
    );
    return originalJson.apply(this, arguments);
  };

  next();
};

async function startHRPortal() {
  const pool = await mysql.createPool({
    host: process.env.MYSQL_HOST || "localhost",
    user: process.env.MYSQL_USER || "root",
    password: process.env.MYSQL_PASSWORD || "",
    database: process.env.MYSQL_DATABASE || "employees",
    connectionLimit: 10,
    queueLimit: 0,
    waitForConnections: true,
  });

  const app = express();
  app.use(express.json());
  app.use(requestLogger("HR-Portal"));

  app.get("/health", (req, res) => {
    res.json({ status: "ok" });
  });

  // 1. Search by hire_date (missing index)
  app.get("/hr/employees/search", async (req, res) => {
    newrelic.setTransactionName("hr-portal-employee-search");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.*, t.title, s.salary, d.dept_name 
        FROM employees e
        LEFT JOIN titles t ON e.emp_no = t.emp_no AND t.to_date = '9999-01-01'
        LEFT JOIN salaries s ON e.emp_no = s.emp_no AND s.to_date = '9999-01-01'
        LEFT JOIN dept_emp de ON e.emp_no = de.emp_no AND de.to_date = '9999-01-01'
        LEFT JOIN departments d ON de.dept_no = d.dept_no
        WHERE e.hire_date = '1990-01-15'
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 2. Search by name or department (inefficient OR + LIKE)
  app.get("/hr/employees/search_by_name_or_dept", async (req, res) => {
    newrelic.setTransactionName("hr-portal-employee-search-by-name-or-dept");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT DISTINCT e.*, d.dept_name 
        FROM employees e
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        WHERE (e.first_name LIKE '%Geo%' OR e.last_name LIKE '%son%')
        OR (de.dept_no = 'd005' AND de.to_date = '9999-01-01')
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 3. List all employees (SELECT * with multiple joins)
  app.get("/hr/employees/list", async (req, res) => {
    newrelic.setTransactionName("hr-portal-employee-list");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.*, d.dept_name, t.title, s.salary
        FROM employees e
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE de.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 4. Employee transfer (N+1 query pattern)
  app.post("/hr/employees/transfer", async (req, res) => {
    newrelic.setTransactionName("hr-portal-employee-transfer");
    const connection = await pool.getConnection();
    try {
      await connection.beginTransaction();

      // Get employees to transfer
      const [employees] = await connection.query(`
        SELECT de.emp_no 
        FROM dept_emp de
        WHERE de.dept_no = 'd005' 
        AND de.to_date = '9999-01-01'
        AND NOT EXISTS (
          SELECT 1 FROM dept_emp de2
          WHERE de2.emp_no = de.emp_no
          AND de2.dept_no = 'd001'
          AND de2.to_date = '9999-01-01'
        )
        LIMIT 100
      `);

      // N+1 pattern intentionally preserved for performance testing
      for (const emp of employees) {
        await connection.query(
          `
          UPDATE dept_emp 
          SET to_date = CURDATE() 
          WHERE emp_no = ? 
          AND to_date = '9999-01-01'
        `,
          [emp.emp_no]
        );

        await connection.query(
          `
          INSERT INTO dept_emp (emp_no, dept_no, from_date, to_date)
          VALUES (?, 'd001', CURDATE(), '9999-01-01')
        `,
          [emp.emp_no]
        );
      }

      await connection.commit();
      res.json({ status: "ok", transferred: employees.length });
    } catch (err) {
      newrelic.noticeError(err);
      await connection.rollback();
      res.status(500).json({ error: err.message });
    } finally {
      connection.release();
    }
  });

  // 5. Update salary with default values
  app.put("/hr/employees/update_salary", async (req, res) => {
    newrelic.setTransactionName("hr-portal-employee-update-salary");
    let connection;
    try {
      connection = await pool.getConnection();
      // Get a random employee if none provided
      let emp_no = req.body.emp_no;
      if (!emp_no) {
        const [emps] = await connection.query(`
        SELECT emp_no FROM employees ORDER BY RAND() LIMIT 1
      `);
        emp_no = emps[0].emp_no;
      }

      // Generate random salary increase if none provided
      let salary = req.body.salary;
      if (!salary) {
        const [current] = await connection.query(
          `
        SELECT salary FROM salaries 
        WHERE emp_no = ? AND to_date = '9999-01-01'
      `,
          [emp_no]
        );
        salary = Math.floor(current[0].salary * (1 + Math.random() * 0.2));
      }

      await connection.query(
        `
      UPDATE salaries 
      SET to_date = CURDATE()
      WHERE emp_no = ? 
      AND to_date = '9999-01-01'
    `,
        [emp_no]
      );

      await connection.query(
        `
      INSERT INTO salaries (emp_no, salary, from_date, to_date)
      VALUES (?, ?, CURDATE(), '9999-01-01')
    `,
        [emp_no, salary]
      );

      res.json({ status: "ok" });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 6. Employees by department
  app.get("/hr/reports/employees_by_department", async (req, res) => {
    newrelic.setTransactionName("hr-portal-employees-by-department");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT d.dept_no, d.dept_name, 
               COUNT(DISTINCT e.emp_no) as employee_count,
               AVG(s.salary) as avg_salary
        FROM departments d
        JOIN dept_emp de ON d.dept_no = de.dept_no
        JOIN employees e ON de.emp_no = e.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE de.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        GROUP BY d.dept_no, d.dept_name
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Add to hr-portal/app.js
  app.get("/hr/reports/employees/sorted", async (req, res) => {
    newrelic.setTransactionName("hr-portal-employees-sorted");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
      SELECT 
        e.emp_no,
        e.first_name,
        e.last_name,
        e.hire_date,
        t.title,
        s.salary,
        d.dept_name,
        DATEDIFF(CURDATE(), e.hire_date) as days_employed
      FROM employees e
      JOIN titles t ON e.emp_no = t.emp_no
      JOIN salaries s ON e.emp_no = s.emp_no
      JOIN dept_emp de ON e.emp_no = de.emp_no
      JOIN departments d ON de.dept_no = d.dept_no
      WHERE t.to_date = '9999-01-01'
      AND s.to_date = '9999-01-01'
      AND de.to_date = '9999-01-01'
      ORDER BY days_employed DESC, salary DESC
    `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Add missing salary distribution endpoint
  app.get("/hr/reports/salary/distribution", async (req, res) => {
    newrelic.setTransactionName("hr-portal-salary-distribution");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          FLOOR(salary/10000)*10000 as salary_range,
          COUNT(*) as employee_count
        FROM salaries
        WHERE to_date = '9999-01-01'
        GROUP BY salary_range
        ORDER BY salary_range
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Add missing salary above average endpoint
  app.get("/hr/reports/salary/above_average", async (req, res) => {
    newrelic.setTransactionName("hr-portal-salary-above-average");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        WITH avg_salary AS (
          SELECT AVG(salary) as avg_sal
          FROM salaries
          WHERE to_date = '9999-01-01'
        )
        SELECT 
          e.emp_no,
          e.first_name,
          e.last_name,
          s.salary,
          t.title,
          d.dept_name,
          s.salary - avg_salary.avg_sal as difference_from_avg
        FROM employees e
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        CROSS JOIN avg_salary
        WHERE s.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        AND s.salary > avg_salary.avg_sal
        ORDER BY difference_from_avg DESC
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Add missing employee performance endpoint
  app.get("/hr/employees/performance", async (req, res) => {
    newrelic.setTransactionName("hr-portal-employee-performance");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.emp_no, e.first_name, e.last_name,
               t.title,
               s.salary,
               DATEDIFF(CURDATE(), e.hire_date)/365 as years_employed
        FROM employees e
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Add error handling middleware
  app.use((err, req, res, next) => {
    newrelic.noticeError(err);
    console.error(`Error in ${req.method} ${req.path}:`, err);
    res.status(500).json({
      error: err.message,
      path: req.path,
      method: req.method,
    });
  });

  const port = process.env.PORT || 3000;
  app.listen(port, () => console.log(`HR Portal running on port ${port}`));
}

startHRPortal().catch(console.error);

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\hr-portal\Dockerfile---
FROM node:18-alpine

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

ARG PORT=3000
ENV PORT=${PORT}

COPY . .

EXPOSE ${PORT}

HEALTHCHECK --interval=5s --timeout=3s --start-period=5s --retries=3 CMD curl -f http://localhost:${PORT}/health || exit 1

CMD ["node", "--max-old-space-size=2048", "app.js"]

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\hr-portal\newrelic.js---
'use strict';

exports.config = {
  app_name: ['HR-Portal'],
  license_key: process.env.NEW_RELIC_LICENSE_KEY,
  distributed_tracing: {
    enabled: true
  },
  transaction_tracer: {
    record_sql: 'raw',
    explain_threshold: 500
  },
  slow_sql: {
    enabled: true,
    max_samples: 10
  },
  logging: {
    level: 'info'
  }
};

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\hr-portal\package.json---
{
  "name": "hr-portal",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.5",
    "newrelic": "12.8.2"
  }
}

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\k6\load-test.js---
import http from 'k6/http';
import { check, sleep } from 'k6';
import { randomIntBetween } from 'k6/crypto';

export const options = {
  scenarios: {
    hr_portal: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '2m', target: 8 },
        { duration: '5m', target: 8 },
        { duration: '2m', target: 0 }
      ],
      exec: 'hrPortal'
    },
    payroll_system: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '2m', target: 6 },
        { duration: '5m', target: 6 },
        { duration: '2m', target: 0 }
      ],
      exec: 'payrollSystem'
    },
    reporting_dashboard: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '2m', target: 10 },
        { duration: '5m', target: 10 },
        { duration: '2m', target: 0 }
      ],
      exec: 'reportingDashboard'
    },
    performance_review: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '2m', target: 4 },
        { duration: '5m', target: 4 },
        { duration: '2m', target: 0 }
      ],
      exec: 'performanceReview'
    },
    admin_console: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '2m', target: 2 },
        { duration: '5m', target: 2 },
        { duration: '2m', target: 0 }
      ],
      exec: 'adminConsole'
    }
  },
  thresholds: {
    http_req_duration: ['p(95)<8000']  // 8s for 95th percentile
  }
};

const BASE_URLS = {
  HR_PORTAL: __ENV.HR_PORTAL_URL || 'http://hr-portal:3000',
  PAYROLL: __ENV.PAYROLL_SYSTEM_URL || 'http://payroll-system:3001',
  REPORTING: __ENV.REPORTING_DASHBOARD_URL || 'http://reporting-dashboard:3002',
  PERFORMANCE: __ENV.PERFORMANCE_REVIEW_URL || 'http://performance-review:3003',
  ADMIN: __ENV.ADMIN_CONSOLE_URL || 'http://admin-console:3004'
};

function makeRequest(baseUrl, endpoint) {
  const url = `${baseUrl}${endpoint.path}`;
  const params = {
    headers: { 'Content-Type': 'application/json' }
  };

  try {
    let response;
    switch (endpoint.method.toUpperCase()) {
      case 'GET':
        response = http.get(url, params);
        break;
      case 'POST':
        response = http.post(url, JSON.stringify(endpoint.body || {}), params);
        break;
      case 'PUT':
        response = http.put(url, JSON.stringify(endpoint.body || {}), params);
        break;
    }

    // Simple status check
    check(response, {
      'status was 200': (r) => r.status === 200
    });

    // Adaptive sleep
    sleep(randomIntBetween(1, 3));

  } catch (err) {
    sleep(2); // Sleep on error
  }
}

// HR Portal endpoints
export function hrPortal() {
  const endpoints = [
    { path: '/hr/employees/search', method: 'GET' },
    { path: '/hr/employees/search_by_name_or_dept', method: 'GET' },
    { path: '/hr/employees/list', method: 'GET' },
    { path: '/hr/employees/transfer', method: 'POST' },
    { path: '/hr/employees/performance', method: 'GET' },
    { path: '/hr/reports/salary/above_average', method: 'GET' },
    { path: '/hr/reports/employees/sorted', method: 'GET' },
    { path: '/hr/reports/salary/distribution', method: 'GET' },
    { path: '/hr/employees/update_salary', method: 'PUT' },
    { path: '/hr/reports/employees_by_department', method: 'GET' }
  ];
  makeRequest(BASE_URLS.HR_PORTAL, endpoints[Math.floor(Math.random() * endpoints.length)]);
}

// Payroll System endpoints
export function payrollSystem() {
  const endpoints = [
    { path: '/payroll/salaries/by_employee', method: 'GET' },
    { path: '/payroll/salaries/by_range', method: 'GET' },
    { path: '/payroll/salaries/adjust', method: 'PUT' },
    { path: '/payroll/employees/list_by_salary', method: 'GET' },
    { path: '/payroll/reports/highest_earners', method: 'GET' },
    { path: '/payroll/salaries/by_year', method: 'GET' },
    { path: '/payroll/departments/avg_salary', method: 'GET' },
    { path: '/payroll/employees/search_by_salary', method: 'GET' },
    { path: '/payroll/employees/high_connection_load', method: 'GET' }
  ];
  makeRequest(BASE_URLS.PAYROLL, endpoints[Math.floor(Math.random() * endpoints.length)]);
}

// Reporting Dashboard endpoints
export function reportingDashboard() {
  const endpoints = [
    { path: '/reports/employees/list_all', method: 'GET' },
    { path: '/reports/employees/search_by_name', method: 'GET' },
    { path: '/reports/departments/average_salary', method: 'GET' },
    { path: '/reports/employees/by_hire_date', method: 'GET' },
    { path: '/reports/employees/by_dept', method: 'GET' },
    { path: '/reports/employees/by_title', method: 'GET' },
    { path: '/reports/employees/long_tenure', method: 'GET' },
    { path: '/reports/salaries/highest_by_dept', method: 'GET' },
    { path: '/reports/employees/concurrent_report_generation', method: 'GET' },
    { path: '/reports/employees/search_by_salary_range', method: 'GET' }
  ];
  makeRequest(BASE_URLS.REPORTING, endpoints[Math.floor(Math.random() * endpoints.length)]);
}

// Performance Review endpoints
export function performanceReview() {
  const endpoints = [
    { path: '/perf/employees/list', method: 'GET' },
    { path: '/perf/employees/reviews', method: 'GET' },
    { path: '/perf/employees/search_by_year', method: 'GET' },
    { path: '/perf/departments/avg_score', method: 'GET' },
    { path: '/perf/employees/top_performers', method: 'GET' },
    { path: '/perf/employees/career_progression', method: 'GET' },
    { path: '/perf/reports/annual_performance_summary', method: 'GET' },
    { path: '/perf/employees/search_by_name_and_review_year', method: 'GET' },
    { path: '/perf/reports/department_performance_comparison', method: 'GET' }
  ];
  makeRequest(BASE_URLS.PERFORMANCE, endpoints[Math.floor(Math.random() * endpoints.length)]);
}

// Admin Console endpoints
export function adminConsole() {
  const endpoints = [
    { path: '/admin/employees/search', method: 'GET' },
    { path: '/admin/departments/details', method: 'GET' },
    { path: '/admin/employees/details', method: 'GET' },
    { path: '/admin/reports/salary_audit', method: 'GET' },
    { path: '/admin/reports/transfer_audit', method: 'GET' },
    { path: '/admin/employees/data_export', method: 'GET' },
    { path: '/admin/employees/update_multiple', method: 'PUT' },
    { path: '/admin/employees/bulk_title_update', method: 'PUT' }
  ];
  makeRequest(BASE_URLS.ADMIN, endpoints[Math.floor(Math.random() * endpoints.length)]);
}
---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\payroll-system\app.js---
// payroll-system/app.js
const newrelic = require('newrelic');
console.log('New Relic agent status:', newrelic.agent.config.agent_enabled);
const express = require('express');
const mysql = require('mysql2/promise');

// Basic logging middleware
const requestLogger = (serviceName) => (req, res, next) => {
  const startTime = Date.now();
  
  // Override res.json to capture the response
  const originalJson = res.json;
  res.json = function(data) {
    const duration = Date.now() - startTime;
    console.log(`${serviceName} | ${req.method} ${req.originalUrl} | Status: ${res.statusCode} | ${duration}ms${data.error ? ` | Error: ${data.error}` : ''}`);
    return originalJson.apply(this, arguments);
  };

  next();
};

async function startPayrollSystem() {
  const pool = await mysql.createPool({
    host: process.env.MYSQL_HOST || 'localhost',
    user: process.env.MYSQL_USER || 'root',
    password: process.env.MYSQL_PASSWORD || '',
    database: process.env.MYSQL_DATABASE || 'employees',
    connectionLimit: 10,
    queueLimit: 0,
    waitForConnections: true
  });

  const app = express();
  app.use(express.json());
  app.use(requestLogger('Payroll-System'));

  app.get('/health', (req, res) => {
    res.json({ status: 'ok' });
  });

  // 1. Basic salary retrieval
  app.get('/payroll/salaries/by_employee', async (req, res) => {
    newrelic.setTransactionName('payroll-system-salary-by-employee');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.emp_no, e.first_name, e.last_name,
               s.salary, s.from_date, s.to_date,
               d.dept_name, t.title
        FROM employees e
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        JOIN titles t ON e.emp_no = t.emp_no
        WHERE e.emp_no = ?
        AND s.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
      `, [10001]);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 2. Salary range search (inefficient index usage)
  app.get('/payroll/salaries/by_range', async (req, res) => {
    newrelic.setTransactionName('payroll-system-salary-by-range');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.*, s.salary, d.dept_name
        FROM employees e
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        WHERE s.salary BETWEEN 50000 AND 70000
        AND s.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        ORDER BY s.salary DESC
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 3. Salary adjustment (long-running transaction)
  app.put('/payroll/salaries/adjust', async (req, res) => {
    newrelic.setTransactionName('payroll-system-salary-adjust');
    const connection = await pool.getConnection();
    try {
      await connection.beginTransaction();
      
      await connection.query(`
        UPDATE salaries s
        JOIN dept_emp de ON s.emp_no = de.emp_no
        SET s.to_date = CURDATE()
        WHERE de.dept_no = 'd005'
        AND s.to_date = '9999-01-01'
      `);

      await connection.query(`
        INSERT INTO salaries (emp_no, salary, from_date, to_date)
        SELECT s.emp_no, s.salary * 1.1, CURDATE(), '9999-01-01'
        FROM salaries s
        JOIN dept_emp de ON s.emp_no = de.emp_no
        WHERE de.dept_no = 'd005'
        AND s.to_date = CURDATE()
      `);
      
      // Artificial delay
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      await connection.commit();
      res.json({ status: 'ok' });
    } catch (err) {
      newrelic.noticeError(err);
      await connection.rollback();
      res.status(500).json({ error: err.message });
    } finally {
      connection.release();
    }
  });

  // 4. List by salary (inefficient sorting)
  app.get('/payroll/employees/list_by_salary', async (req, res) => {
    newrelic.setTransactionName('payroll-system-employee-list-by-salary');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.emp_no, e.first_name, e.last_name,
               s.salary, t.title, d.dept_name
        FROM employees e
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        WHERE s.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        ORDER BY s.salary DESC
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 5. Highest earners (no LIMIT)
  app.get('/payroll/reports/highest_earners', async (req, res) => {
    newrelic.setTransactionName('payroll-system-highest-earners');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.*, s.salary, d.dept_name, t.title
        FROM employees e
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        JOIN titles t ON e.emp_no = t.emp_no
        WHERE s.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
        ORDER BY s.salary DESC
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 6. Salary by year (function-based filter)
  app.get('/payroll/salaries/by_year', async (req, res) => {
    newrelic.setTransactionName('payroll-system-salary-by-year');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.emp_no, e.first_name, e.last_name,
               s.salary, s.from_date, s.to_date
        FROM employees e
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE YEAR(s.from_date) = 1995
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 7. Department average salary
  app.get('/payroll/departments/avg_salary', async (req, res) => {
    newrelic.setTransactionName('payroll-system-department-avg-salary');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT d.dept_name, 
               COUNT(DISTINCT e.emp_no) as emp_count,
               AVG(s.salary) as avg_salary,
               MAX(s.salary) as max_salary,
               MIN(s.salary) as min_salary
        FROM departments d
        JOIN dept_emp de ON d.dept_no = de.dept_no
        JOIN employees e ON de.emp_no = e.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE de.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        GROUP BY d.dept_name
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 8. Search by salary (implicit conversion)
  app.get('/payroll/employees/search_by_salary', async (req, res) => {
    newrelic.setTransactionName('payroll-system-employee-search-by-salary');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.emp_no, e.first_name, e.last_name,
               s.salary, t.title
        FROM employees e
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN titles t ON e.emp_no = t.emp_no
        WHERE s.salary BETWEEN '70000' AND '90000'
        AND s.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 9. High connection load simulation
  app.get('/payroll/employees/high_connection_load', async (req, res) => {
    newrelic.setTransactionName('payroll-system-high-connection-load');
    const connections = [];
    try {
      for (let i = 0; i < 20; i++) {
        const conn = await pool.getConnection();
        connections.push(conn);
        await conn.query(`
          SELECT e.*, s.salary
          FROM employees e
          JOIN salaries s ON e.emp_no = s.emp_no
          WHERE e.emp_no = ?
          AND s.to_date = '9999-01-01'
        `, [10001 + i]);
      }
      res.json({ status: 'ok' });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      connections.forEach(conn => conn.release());
    }
  });

  const port = process.env.PORT || 3001;
  app.listen(port, () => console.log(`Payroll System running on port ${port}`));
}

startPayrollSystem().catch(console.error);

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\payroll-system\Dockerfile---
FROM node:18-alpine

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

ARG PORT=3001
ENV PORT=${PORT}

COPY . .

EXPOSE ${PORT}

HEALTHCHECK --interval=5s --timeout=3s --start-period=5s --retries=3 CMD curl -f http://localhost:${PORT}/health || exit 1

CMD ["node", "--max-old-space-size=2048", "app.js"]

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\payroll-system\newrelic.js---
'use strict';

exports.config = {
  app_name: ['Payroll-System'],
  license_key: process.env.NEW_RELIC_LICENSE_KEY,
  distributed_tracing: {
    enabled: true
  },
  transaction_tracer: {
    record_sql: 'raw',
    explain_threshold: 500
  },
  slow_sql: {
    enabled: true,
    max_samples: 10
  },
  logging: {
    level: 'info'
  }
};

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\payroll-system\package.json---
{
  "name": "payroll-system",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.5",
    "newrelic": "12.8.2"
  }
}

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\performance-review\app.js---
// performance-review/app.js
const newrelic = require("newrelic");
console.log("New Relic agent status:", newrelic.agent.config.agent_enabled);
const express = require("express");
const mysql = require("mysql2/promise");

// Basic logging middleware
const requestLogger = (serviceName) => (req, res, next) => {
  const startTime = Date.now();

  // Override res.json to capture the response
  const originalJson = res.json;
  res.json = function (data) {
    const duration = Date.now() - startTime;
    console.log(
      `${serviceName} | ${req.method} ${req.originalUrl} | Status: ${
        res.statusCode
      } | ${duration}ms${data.error ? ` | Error: ${data.error}` : ""}`
    );
    return originalJson.apply(this, arguments);
  };

  next();
};

async function startPerformanceReview() {
  const pool = await mysql.createPool({
    host: process.env.MYSQL_HOST || "localhost",
    user: process.env.MYSQL_USER || "root",
    password: process.env.MYSQL_PASSWORD || "",
    database: process.env.MYSQL_DATABASE || "employees",
    connectionLimit: 10,
    queueLimit: 0,
    waitForConnections: true,
  });

  const app = express();
  app.use(express.json());
  app.use(requestLogger("Performance-Review"));

  app.get("/health", (req, res) => {
    res.json({ status: "ok" });
  });

  // 1. Employee list with performance indicators
  app.get("/perf/employees/list", async (req, res) => {
    newrelic.setTransactionName("performance-review-employee-list");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          e.emp_no,
          e.first_name,
          e.last_name,
          t.title,
          d.dept_name,
          s.salary,
          DATEDIFF(CURDATE(), e.hire_date) / 365 as years_of_service,
          (SELECT COUNT(DISTINCT title) 
           FROM titles 
           WHERE emp_no = e.emp_no) as role_changes,
          (SELECT MAX(salary) - MIN(salary) 
           FROM salaries 
           WHERE emp_no = e.emp_no) as salary_growth
        FROM employees e
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE t.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 2. Career progression analysis
  app.get("/perf/employees/career_progression", async (req, res) => {
    newrelic.setTransactionName("performance-review-career-progression");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          e.emp_no,
          e.first_name,
          e.last_name,
          t1.title as current_title,
          t1.from_date as current_title_date,
          s.salary as current_salary,
          d.dept_name,
          (SELECT title 
           FROM titles t2 
           WHERE t2.emp_no = e.emp_no 
           AND t2.from_date < t1.from_date 
           ORDER BY t2.from_date DESC LIMIT 1) as previous_title,
          (SELECT salary 
           FROM salaries s2 
           WHERE s2.emp_no = e.emp_no 
           AND s2.from_date < s.from_date 
           ORDER BY s2.from_date DESC LIMIT 1) as previous_salary
        FROM employees e
        JOIN titles t1 ON e.emp_no = t1.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        WHERE t1.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 3. Department performance metrics
  app.get("/perf/departments/avg_score", async (req, res) => {
    newrelic.setTransactionName("performance-review-department-avg-score");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          d.dept_name,
          COUNT(DISTINCT e.emp_no) as employee_count,
          AVG(s.salary) as avg_salary,
          MAX(s.salary) as max_salary,
          MIN(s.salary) as min_salary,
          COUNT(DISTINCT t.title) as title_diversity,
          AVG(DATEDIFF(CURDATE(), e.hire_date)) as avg_tenure_days,
          (SELECT COUNT(DISTINCT emp_no) 
           FROM titles t2 
           WHERE t2.title LIKE 'Senior%' 
           AND t2.emp_no IN (
             SELECT emp_no 
             FROM dept_emp de2 
             WHERE de2.dept_no = d.dept_no 
             AND de2.to_date = '9999-01-01'
           )) as senior_employees
        FROM departments d
        JOIN dept_emp de ON d.dept_no = de.dept_no
        JOIN employees e ON de.emp_no = e.emp_no
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE de.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        GROUP BY d.dept_name
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Employee reviews endpoint
  app.get("/perf/employees/reviews", async (req, res) => {
    newrelic.setTransactionName("performance-review-employee-reviews");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          e.emp_no,
          e.first_name,
          e.last_name,
          t.title,
          s.salary,
          d.dept_name,
          DATEDIFF(CURDATE(), e.hire_date) / 365 as years_of_service,
          (SELECT COUNT(*) 
           FROM titles t2 
           WHERE t2.emp_no = e.emp_no) as role_changes,
          CASE
            WHEN DATEDIFF(CURDATE(), e.hire_date) / 365 >= 15 THEN 'Senior'
            WHEN DATEDIFF(CURDATE(), e.hire_date) / 365 >= 10 THEN 'Experienced'
            WHEN DATEDIFF(CURDATE(), e.hire_date) / 365 >= 5 THEN 'Mid-Level'
            ELSE 'Junior'
          END as experience_level
        FROM employees e
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        WHERE t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        ORDER BY years_of_service DESC
      `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Department performance comparison endpoint
  app.get(
    "/perf/reports/department_performance_comparison",
    async (req, res) => {
      newrelic.setTransactionName("performance-review-department-comparison");
      let connection;
      try {
        connection = await pool.getConnection();
        const [rows] = await connection.query(`
        SELECT 
          d.dept_name,
          COUNT(DISTINCT e.emp_no) as employee_count,
          AVG(s.salary) as avg_salary,
          AVG(DATEDIFF(CURDATE(), e.hire_date) / 365) as avg_years_of_service,
          COUNT(DISTINCT 
            CASE WHEN t.title LIKE 'Senior%' 
                 THEN e.emp_no 
            END
          ) as senior_employee_count,
          (SELECT COUNT(DISTINCT t2.title) 
           FROM titles t2 
           JOIN dept_emp de2 ON t2.emp_no = de2.emp_no 
           WHERE de2.dept_no = d.dept_no) as unique_roles,
          MAX(s.salary) - MIN(s.salary) as salary_range
        FROM departments d
        JOIN dept_emp de ON d.dept_no = de.dept_no
        JOIN employees e ON de.emp_no = e.emp_no
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE de.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        GROUP BY d.dept_name
        ORDER BY avg_salary DESC
      `);
        res.json({ status: "ok", data: rows });
      } catch (err) {
        newrelic.noticeError(err);
        res.status(500).json({ error: err.message });
      } finally {
        if (connection) connection.release();
      }
    }
  );

  // Add to performance-review/app.js

  // Top performers endpoint
  app.get("/perf/employees/top_performers", async (req, res) => {
    newrelic.setTransactionName("performance-review-top-performers");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
      SELECT 
        e.emp_no,
        e.first_name,
        e.last_name,
        t.title,
        s.salary,
        d.dept_name,
        s.salary - (
          SELECT AVG(s2.salary)
          FROM salaries s2
          JOIN dept_emp de2 ON s2.emp_no = de2.emp_no
          WHERE de2.dept_no = de.dept_no
          AND s2.to_date = '9999-01-01'
        ) as salary_above_dept_avg
      FROM employees e
      JOIN titles t ON e.emp_no = t.emp_no
      JOIN dept_emp de ON e.emp_no = de.emp_no
      JOIN departments d ON de.dept_no = d.dept_no
      JOIN salaries s ON e.emp_no = s.emp_no
      WHERE t.to_date = '9999-01-01'
      AND de.to_date = '9999-01-01'
      AND s.to_date = '9999-01-01'
      HAVING salary_above_dept_avg > 0
      ORDER BY salary_above_dept_avg DESC
    `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Annual performance summary
  app.get("/perf/reports/annual_performance_summary", async (req, res) => {
    newrelic.setTransactionName("performance-review-annual-summary");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
      SELECT 
        YEAR(s.from_date) as year,
        d.dept_name,
        COUNT(DISTINCT e.emp_no) as total_employees,
        AVG(s.salary) as avg_salary,
        COUNT(DISTINCT t.title) as title_count,
        SUM(CASE WHEN t.title LIKE 'Senior%' THEN 1 ELSE 0 END) as senior_positions
      FROM employees e
      JOIN dept_emp de ON e.emp_no = de.emp_no
      JOIN departments d ON de.dept_no = d.dept_no
      JOIN titles t ON e.emp_no = t.emp_no
      JOIN salaries s ON e.emp_no = s.emp_no
      WHERE t.to_date = '9999-01-01'
      AND de.to_date = '9999-01-01'
      AND s.to_date = '9999-01-01'
      GROUP BY YEAR(s.from_date), d.dept_name
      ORDER BY year DESC, d.dept_name
    `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Search by name and review year
  app.get(
    "/perf/employees/search_by_name_and_review_year",
    async (req, res) => {
      newrelic.setTransactionName("performance-review-search-by-name-year");
      let connection;
      try {
        connection = await pool.getConnection();
        const [rows] = await connection.query(`
      SELECT 
        e.emp_no,
        e.first_name,
        e.last_name,
        e.hire_date,
        t.title,
        d.dept_name,
        s.salary,
        YEAR(e.hire_date) as hire_year,
        (SELECT COUNT(DISTINCT title) 
         FROM titles 
         WHERE emp_no = e.emp_no) as role_changes
      FROM employees e
      JOIN titles t ON e.emp_no = t.emp_no
      JOIN dept_emp de ON e.emp_no = de.emp_no
      JOIN departments d ON de.dept_no = d.dept_no
      JOIN salaries s ON e.emp_no = s.emp_no
      WHERE (e.first_name LIKE '%John%' OR e.last_name LIKE '%Smith%')
      AND YEAR(e.hire_date) = 1990
      AND t.to_date = '9999-01-01'
      AND de.to_date = '9999-01-01'
      AND s.to_date = '9999-01-01'
    `);
        res.json({ status: "ok", data: rows });
      } catch (err) {
        newrelic.noticeError(err);
        res.status(500).json({ error: err.message });
      } finally {
        if (connection) connection.release();
      }
    }
  );
  // search_by_year endpoint
  app.get("/perf/employees/search_by_year", async (req, res) => {
    newrelic.setTransactionName("performance-review-search-by-year");
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
      SELECT e.emp_no, 
             e.first_name, 
             e.last_name,
             t.title,
             YEAR(e.hire_date) as hire_year,
             COUNT(DISTINCT s.salary) as salary_changes
      FROM employees e
      JOIN titles t ON e.emp_no = t.emp_no
      JOIN salaries s ON e.emp_no = s.emp_no
      WHERE t.to_date = '9999-01-01'
      AND YEAR(e.hire_date) = 1990
      GROUP BY e.emp_no, e.first_name, e.last_name, t.title, YEAR(e.hire_date)
    `);
      res.json({ status: "ok", data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // Add error handling middleware
  app.use((err, req, res, next) => {
    newrelic.noticeError(err);
    console.error(`Error in ${req.method} ${req.path}:`, err);
    res.status(500).json({
      error: err.message,
      path: req.path,
      method: req.method,
    });
  });

  const port = process.env.PORT || 3003;
  app.listen(port, () =>
    console.log(`Performance Review System running on port ${port}`)
  );
}

startPerformanceReview().catch(console.error);

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\performance-review\Dockerfile---
FROM node:18-alpine

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

ARG PORT=3003
ENV PORT=${PORT}

COPY . .

EXPOSE ${PORT}

HEALTHCHECK --interval=5s --timeout=3s --start-period=5s --retries=3 CMD curl -f http://localhost:${PORT}/health || exit 1

CMD ["node", "--max-old-space-size=2048", "app.js"]

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\performance-review\newrelic.js---
'use strict';

exports.config = {
  app_name: ['Performance-Review'],
  license_key: process.env.NEW_RELIC_LICENSE_KEY,
  distributed_tracing: {
    enabled: true
  },
  transaction_tracer: {
    record_sql: 'raw',
    explain_threshold: 500
  },
  slow_sql: {
    enabled: true,
    max_samples: 10
  },
  logging: {
    level: 'info'
  }
};

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\performance-review\package.json---
{
  "name": "performance-review",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.5",
    "newrelic": "12.8.2"
  }
}

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\reporting-dashboard\app.js---
// reporting-dashboard/app.js
const newrelic = require('newrelic');
console.log('New Relic agent status:', newrelic.agent.config.agent_enabled);
const express = require('express');
const mysql = require('mysql2/promise');

// Basic logging middleware
const requestLogger = (serviceName) => (req, res, next) => {
  const startTime = Date.now();
  
  // Override res.json to capture the response
  const originalJson = res.json;
  res.json = function(data) {
    const duration = Date.now() - startTime;
    console.log(`${serviceName} | ${req.method} ${req.originalUrl} | Status: ${res.statusCode} | ${duration}ms${data.error ? ` | Error: ${data.error}` : ''}`);
    return originalJson.apply(this, arguments);
  };

  next();
};

async function startReportingDashboard() {
  const pool = await mysql.createPool({
    host: process.env.MYSQL_HOST || 'localhost',
    user: process.env.MYSQL_USER || 'root',
    password: process.env.MYSQL_PASSWORD || '',
    database: process.env.MYSQL_DATABASE || 'employees',
    connectionLimit: 10,
    queueLimit: 0,
    waitForConnections: true
  });

  const app = express();
  app.use(express.json());
  app.use(requestLogger('Reporting-Dashboard'));

  app.get('/health', (req, res) => {
    res.json({ status: 'ok' });
  });

  // 1. List all employees with full details (expensive join)
  app.get('/reports/employees/list_all', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-employee-list-all');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.*, d.dept_name, t.title, s.salary,
               DATEDIFF(CURDATE(), e.hire_date) as days_employed
        FROM employees e
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE de.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        ORDER BY e.emp_no
        LIMIT 1000
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 2. Department salary statistics (complex aggregation)
  app.get('/reports/departments/average_salary', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-department-average-salary');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          d.dept_name,
          COUNT(DISTINCT e.emp_no) as employee_count,
          ROUND(AVG(s.salary), 2) as avg_salary,
          MIN(s.salary) as min_salary,
          MAX(s.salary) as max_salary,
          COUNT(DISTINCT t.title) as title_count
        FROM departments d
        JOIN dept_emp de ON d.dept_no = de.dept_no
        JOIN employees e ON de.emp_no = e.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN titles t ON e.emp_no = t.emp_no
        WHERE de.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        AND t.to_date = '9999-01-01'
        GROUP BY d.dept_name
        ORDER BY avg_salary DESC
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 3. Employee hire date analysis (function-based WHERE)
  app.get('/reports/employees/by_hire_date', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-employee-by-hire-date');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          YEAR(hire_date) as hire_year,
          MONTH(hire_date) as hire_month,
          COUNT(*) as hire_count,
          COUNT(DISTINCT de.dept_no) as dept_count
        FROM employees e
        JOIN dept_emp de ON e.emp_no = de.emp_no
        WHERE YEAR(hire_date) BETWEEN 1985 AND 1995
        GROUP BY hire_year, hire_month
        ORDER BY hire_year, hire_month
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 4. Department headcount trends (correlated subquery)
  app.get('/reports/employees/by_dept', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-employee-by-dept');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          d.dept_name,
          COUNT(de.emp_no) as current_count,
          (
            SELECT COUNT(*)
            FROM dept_emp de2
            WHERE de2.dept_no = d.dept_no
            AND YEAR(de2.from_date) = YEAR(CURDATE())
          ) as new_hires_this_year,
          (
            SELECT COUNT(*)
            FROM dept_emp de3
            WHERE de3.dept_no = d.dept_no
            AND YEAR(de3.to_date) = YEAR(CURDATE())
            AND de3.to_date != '9999-01-01'
          ) as departures_this_year
        FROM departments d
        JOIN dept_emp de ON d.dept_no = de.dept_no
        WHERE de.to_date = '9999-01-01'
        GROUP BY d.dept_name
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 5. Salary distribution by title (temp tables)
  app.get('/reports/employees/by_title', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-employee-by-title');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          t.title,
          COUNT(*) as employee_count,
          ROUND(AVG(s.salary), 2) as avg_salary,
          MIN(s.salary) as min_salary,
          MAX(s.salary) as max_salary,
          ROUND(STDDEV(s.salary), 2) as salary_stddev
        FROM titles t
        JOIN salaries s ON t.emp_no = s.emp_no
        WHERE t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        GROUP BY t.title
        ORDER BY avg_salary DESC
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 6. Employee tenure analysis (date calculations)
  app.get('/reports/employees/long_tenure', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-employee-long-tenure');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          e.emp_no,
          e.first_name,
          e.last_name,
          e.hire_date,
          DATEDIFF(CURDATE(), e.hire_date) as tenure_days,
          COUNT(DISTINCT t.title) as number_of_titles,
          COUNT(DISTINCT de.dept_no) as number_of_departments
        FROM employees e
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        WHERE DATEDIFF(CURDATE(), hire_date) > 365 * 10
        GROUP BY e.emp_no, e.first_name, e.last_name, e.hire_date
        ORDER BY tenure_days DESC
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 7. Department salary rankings (window functions simulation)
  app.get('/reports/salaries/highest_by_dept', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-salaries-highest-by-dept');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          d.dept_name,
          e.first_name,
          e.last_name,
          s.salary,
          (
            SELECT COUNT(DISTINCT s2.salary) + 1
            FROM salaries s2
            JOIN dept_emp de2 ON s2.emp_no = de2.emp_no
            WHERE de2.dept_no = de.dept_no
            AND s2.salary > s.salary
            AND s2.to_date = '9999-01-01'
            AND de2.to_date = '9999-01-01'
          ) as salary_rank_in_dept
        FROM departments d
        JOIN dept_emp de ON d.dept_no = de.dept_no
        JOIN employees e ON de.emp_no = e.emp_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE de.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        HAVING salary_rank_in_dept <= 5
        ORDER BY d.dept_name, salary_rank_in_dept
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  // 8. Concurrent report generation (connection stress)
  app.get('/reports/employees/concurrent_report_generation', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-concurrent-report-generation');
    const connections = [];
    try {
      const promises = Array(15).fill().map(async () => {
        const conn = await pool.getConnection();
        connections.push(conn);
        return conn.query(`
          SELECT e.*, s.salary, t.title
          FROM employees e
          JOIN salaries s ON e.emp_no = s.emp_no
          JOIN titles t ON e.emp_no = t.emp_no
          WHERE s.to_date = '9999-01-01'
          AND t.to_date = '9999-01-01'
          AND e.hire_date BETWEEN '1985-01-01' AND '1995-12-31'
        `);
      });
      await Promise.all(promises);
      res.json({ status: 'ok' });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      connections.forEach(conn => conn.release());
    }
  });

  // 9. Salary range analysis (string comparison)
  app.get('/reports/employees/search_by_salary_range', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-employee-search-by-salary-range');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT e.emp_no, e.first_name, e.last_name,
               s.salary, t.title, d.dept_name
        FROM employees e
        JOIN salaries s ON e.emp_no = s.emp_no
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        WHERE s.salary BETWEEN '60000' AND '80000'
        AND t.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        ORDER BY s.salary DESC
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

    // Add the missing search by name endpoint
  app.get('/reports/employees/search_by_name', async (req, res) => {
    newrelic.setTransactionName('reporting-dashboard-employee-search-by-name');
    let connection;
    try {
      connection = await pool.getConnection();
      const [rows] = await connection.query(`
        SELECT 
          e.emp_no,
          e.first_name,
          e.last_name,
          t.title,
          d.dept_name,
          s.salary
        FROM employees e
        JOIN titles t ON e.emp_no = t.emp_no
        JOIN dept_emp de ON e.emp_no = de.emp_no
        JOIN departments d ON de.dept_no = d.dept_no
        JOIN salaries s ON e.emp_no = s.emp_no
        WHERE (e.first_name LIKE '%John%' OR e.last_name LIKE '%Smith%')
        AND t.to_date = '9999-01-01'
        AND de.to_date = '9999-01-01'
        AND s.to_date = '9999-01-01'
        ORDER BY e.last_name, e.first_name
      `);
      res.json({ status: 'ok', data: rows });
    } catch (err) {
      newrelic.noticeError(err);
      res.status(500).json({ error: err.message });
    } finally {
      if (connection) connection.release();
    }
  });

  const port = process.env.PORT || 3002;
  app.listen(port, () => console.log(`Reporting Dashboard running on port ${port}`));
}

startReportingDashboard().catch(console.error);

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\reporting-dashboard\Dockerfile---
FROM node:18-alpine

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

ARG PORT=3002
ENV PORT=${PORT}

COPY . .

EXPOSE ${PORT}

HEALTHCHECK --interval=5s --timeout=3s --start-period=5s --retries=3 CMD curl -f http://localhost:${PORT}/health || exit 1

CMD ["node", "--max-old-space-size=2048", "app.js"]

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\reporting-dashboard\newrelic.js---
'use strict';

exports.config = {
  app_name: ['Reporting-Dashboard'],
  license_key: process.env.NEW_RELIC_LICENSE_KEY,
  distributed_tracing: {
    enabled: true
  },
  transaction_tracer: {
    record_sql: 'raw',
    explain_threshold: 500
  },
  slow_sql: {
    enabled: true,
    max_samples: 10
  },
  logging: {
    level: 'info'
  }
};

---File: C:\Users\hi\Desktop\SourceCode\db-perf-env\mysql\reporting-dashboard\package.json---
{
  "name": "reporting-dashboard",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.5",
    "newrelic": "12.8.2"
  }
}

